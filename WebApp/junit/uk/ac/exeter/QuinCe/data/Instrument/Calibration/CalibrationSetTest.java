package uk.ac.exeter.QuinCe.data.Instrument.Calibration;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.time.LocalDateTime;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.stream.Stream;

import org.apache.commons.lang3.NotImplementedException;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.CsvSource;
import org.junit.jupiter.params.provider.MethodSource;
import org.mockito.Mockito;

import uk.ac.exeter.QuinCe.TestBase.BaseTest;
import uk.ac.exeter.QuinCe.data.Instrument.Instrument;
import uk.ac.exeter.QuinCe.utils.ParameterException;

/**
 * Tests for the {@link CalibrationSet} class.
 */
public class CalibrationSetTest extends BaseTest {

  /**
   * Generate a mock {@link Instrument}.
   * 
   * <p>
   * The mocked object does not perform any actions.
   * </p>
   * 
   * @return The mocked Instrument.
   */
  private Instrument getInstrument() {
    return Mockito.mock(Instrument.class);
  }

  /**
   * Generate a mock {@link CalibrationDB} instance.
   * 
   * <p>
   * This instance will only respond to the methods
   * {@link CalibrationDB#timeAffectesCalibration()},
   * {@link CalibrationDB#allowCalibrationChangeInDataset()} and
   * {@link CalibrationDB#usePostCalibrations()} methods with the values
   * supplied.
   * 
   * @param timeAffectsCalibration
   *          The value to be returned by calls to
   *          {@link CalibrationDB#timeAffectesCalibration()}.
   * @param allowCalibrationChangeInDataset
   *          The value to be returned by calls to
   *          {@link CalibrationDB#allowCalibrationChangeInDataset()}.
   * @param usePostCalibrations
   *          The value to be returned by calls to
   *          {@link CalibrationDB#usePostCalibrations()}.
   * @return The mocked {@link CalibrationDB}.
   */
  private CalibrationDB makeDbInstance(boolean timeAffectsCalibration,
    boolean allowCalibrationChangeInDataset, boolean usePostCalibrations) {

    CalibrationDB db = Mockito.mock(CalibrationDB.class);
    Mockito.when(db.timeAffectesCalibration())
      .thenReturn(timeAffectsCalibration);
    Mockito.when(db.allowCalibrationChangeInDataset())
      .thenReturn(allowCalibrationChangeInDataset);
    Mockito.when(db.usePostCalibrations()).thenReturn(usePostCalibrations);

    return db;
  }

  /**
   * Generate the target names used in these tests.
   * 
   * @return The target names.
   */
  private Map<String, String> getTargets() {
    TreeMap<String, String> targets = new TreeMap<String, String>();
    targets.put("TARGET1", "TARGET1");
    targets.put("TARGET2", "TARGET2");
    return targets;
  }

  /**
   * Generate a set of coefficient values for a calibration.
   * 
   * <p>
   * Generates a coefficient named {@code COEF1} with the values supplied.
   * </p>
   * 
   * @param value1
   *          The value for {@code COEF1}.
   * @return The coefficients.
   */
  private Map<String, String> makeCoefficient(String value) {
    TreeMap<String, String> coefficients = new TreeMap<String, String>();
    coefficients.put("COEF1", value);
    return coefficients;
  }

  /**
   * Generate a {@link LocalDateTime} for a specified day in January 2024, with
   * the time set to midnight.
   * 
   * @param day
   *          The day of January.
   * @return The {@link LocalDateTime} object.
   */
  private LocalDateTime makeTime(int day) {
    return LocalDateTime.of(2024, 1, day, 0, 0, 0);
  }

  /**
   * Make a simple set of {@link Calibration}s.
   * 
   * <p>
   * The calibrations generated are shown in the table below. The numbers for
   * each calibration are its database ID, used to verify the test results.
   * </p>
   * <table cellspacing="5">
   * <caption>Calibrations generated by this method, with day numbers in January
   * 2024.</caption>
   * <tr>
   * <th>Target</th>
   * <th align="center">4</th>
   * <th align="center">5</th>
   * <th align="center">10</th>
   * <th align="center">12</th>
   * <th align="center">15</th>
   * <th align="center">17</th>
   * </tr>
   * <tr>
   * <td align="center">TARGET1</td>
   * <td align="center">1</td>
   * <td align="center">&nbsp;</td>
   * <td align="center">2</td>
   * <td align="center">3</td>
   * <td align="center">4</td>
   * <td align="center">&nbsp;</td>
   * </tr>
   * <tr>
   * <td align="center">TARGET2</td>
   * <td align="center">&nbsp;</td>
   * <td align="center">5</td>
   * <td align="center">6</td>
   * <td align="center">&nbsp;</td>
   * <td align="center">&nbsp;</td>
   * <td align="center">7</td>
   * </tr>
   * </table>
   * 
   * @return The calibrations.
   * @throws Exception
   *           If the calibration creation fails.
   * @see #makeCoefficients(String, String)
   */
  private TreeMap<String, TreeSet<Calibration>> makeCalibrations()
    throws Exception {

    Instrument instrument = getInstrument();

    TreeMap<String, TreeSet<Calibration>> calibrations = new TreeMap<String, TreeSet<Calibration>>();

    TreeSet<Calibration> calibs1 = new TreeSet<Calibration>();
    calibs1.add(new TestCalibration(1L, instrument, "TARGET1", makeTime(4),
      makeCoefficient("10"), false));
    calibs1.add(new TestCalibration(2L, instrument, "TARGET1", makeTime(10),
      makeCoefficient("19"), false));
    calibs1.add(new TestCalibration(3L, instrument, "TARGET1", makeTime(12),
      makeCoefficient("20"), false));
    calibs1.add(new TestCalibration(4L, instrument, "TARGET1", makeTime(15),
      makeCoefficient("30"), false));

    calibrations.put("TARGET1", calibs1);

    TreeSet<Calibration> calibs2 = new TreeSet<Calibration>();
    calibs2.add(new TestCalibration(5L, instrument, "TARGET2", makeTime(5),
      makeCoefficient("15"), false));
    calibs2.add(new TestCalibration(6L, instrument, "TARGET2", makeTime(10),
      makeCoefficient("25"), false));
    calibs2.add(new TestCalibration(7L, instrument, "TARGET2", makeTime(17),
      makeCoefficient("35"), false));

    calibrations.put("TARGET2", calibs2);

    return calibrations;
  }

  @ParameterizedTest
  @CsvSource({ "5,6,true", "6,7,false", "9,12,true", "13,14,false",
    "11,15,true", "11,16,true", "18,20,false" })
  public void setupWithInterimTimesTest(int start, int end,
    boolean expectException) throws Exception {

    boolean exceptionThrown = false;

    try {
      new CalibrationSet(getTargets(), makeTime(start), makeTime(end),
        makeDbInstance(false, false, false), makeCalibrations());
    } catch (InvalidCalibrationDateException e) {
      exceptionThrown = true;
    } catch (Exception e) {
      throw e;
    }

    assertEquals(expectException, exceptionThrown);
  }

  @ParameterizedTest
  @CsvSource({ "3,false", "4,false", "5,false", "9,true", "11,true", "13,true",
    "16,true", "18,true" })
  public void completePriorTest(int start, boolean shouldBeComplete)
    throws Exception {

    CalibrationSet calibrationSet = new CalibrationSet(getTargets(),
      makeTime(start), makeTime(20), makeDbInstance(false, true, false),
      makeCalibrations());

    assertEquals(shouldBeComplete, calibrationSet.hasCompletePrior());
  }

  @ParameterizedTest
  @CsvSource({ "3,true", "4,true", "5,true", "9,true", "11,true", "13,true",
    "16,false" })
  public void completePostTest(int end, boolean shouldBeComplete)
    throws Exception {

    CalibrationSet calibrationSet = new CalibrationSet(getTargets(),
      makeTime(1), makeTime(end), makeDbInstance(false, true, true),
      makeCalibrations());

    assertEquals(shouldBeComplete, calibrationSet.hasCompletePost());
  }

  private static Stream<Arguments> getCalibrationsTestParams() {
    return Stream.of(
      Arguments.of(4, 7, 4, new String[] { "TARGET1", "TARGET2" },
        new Long[] { null, null }),
      Arguments.of(4, 7, 5, new String[] { "TARGET1", "TARGET2" },
        new Long[] { 1L, null }),
      Arguments.of(4, 7, 6, new String[] { "TARGET1", "TARGET2" },
        new Long[] { 1L, 5L }),
      Arguments.of(3, 18, 7, new String[] { "TARGET1", "TARGET2" },
        new Long[] { 1L, 5L }),
      Arguments.of(3, 18, 10, new String[] { "TARGET1", "TARGET2" },
        new Long[] { 1L, 5L }),
      Arguments.of(3, 18, 13, new String[] { "TARGET1", "TARGET2" },
        new Long[] { 3L, 6L }),
      Arguments.of(3, 18, 15, new String[] { "TARGET1", "TARGET2" },
        new Long[] { 3L, 6L }),
      Arguments.of(3, 18, 18, new String[] { "TARGET1", "TARGET2" },
        new Long[] { 4L, 7L }));
  }

  @ParameterizedTest
  @MethodSource("getCalibrationsTestParams")
  public void getCalibrationsTest(int start, int end, int checkTime,
    String[] targets, Long[] calibrationIds) throws Exception {

    CalibrationSet calibrationSet = new CalibrationSet(getTargets(),
      makeTime(1), makeTime(end), makeDbInstance(false, true, true),
      makeCalibrations());

    TreeMap<String, Long> expectedCalibrations = new TreeMap<String, Long>();
    for (int i = 0; i < targets.length; i++) {
      expectedCalibrations.put(targets[i], calibrationIds[i]);
    }

    TreeMap<String, Calibration> foundCalibrations = calibrationSet
      .getCalibrations(makeTime(checkTime));

    TreeMap<String, Long> foundCalibrationIds = new TreeMap<String, Long>();
    for (Map.Entry<String, Calibration> entry : foundCalibrations.entrySet()) {
      foundCalibrationIds.put(entry.getKey(),
        null == entry.getValue() ? null : entry.getValue().getId());
    }

    assertTrue(mapsEqual(expectedCalibrations, foundCalibrationIds));
  }

  private static Stream<Arguments> getPostCalibrationsTestParams() {
    return Stream.of(
      Arguments.of(4, 7, 4, new String[] { "TARGET1", "TARGET2" },
        new Long[] { 2L, 5L }),
      Arguments.of(4, 7, 5, new String[] { "TARGET1", "TARGET2" },
        new Long[] { 2L, 6L }),
      Arguments.of(4, 7, 6, new String[] { "TARGET1", "TARGET2" },
        new Long[] { 2L, 6L }),
      Arguments.of(3, 18, 7, new String[] { "TARGET1", "TARGET2" },
        new Long[] { 2L, 6L }),
      Arguments.of(3, 18, 10, new String[] { "TARGET1", "TARGET2" },
        new Long[] { 3L, 7L }),
      Arguments.of(3, 18, 13, new String[] { "TARGET1", "TARGET2" },
        new Long[] { 4L, 7L }),
      Arguments.of(3, 18, 15, new String[] { "TARGET1", "TARGET2" },
        new Long[] { null, 7L }),
      Arguments.of(3, 18, 18, new String[] { "TARGET1", "TARGET2" },
        new Long[] { null, null }));
  }

  @ParameterizedTest
  @MethodSource("getPostCalibrationsTestParams")
  public void getPostCalibrationsTest(int start, int end, int checkTime,
    String[] targets, Long[] calibrationIds) throws Exception {

    CalibrationSet calibrationSet = new CalibrationSet(getTargets(),
      makeTime(1), makeTime(end), makeDbInstance(false, true, true),
      makeCalibrations());

    TreeMap<String, Long> expectedCalibrations = new TreeMap<String, Long>();
    for (int i = 0; i < targets.length; i++) {
      expectedCalibrations.put(targets[i], calibrationIds[i]);
    }

    TreeMap<String, Calibration> foundCalibrations = calibrationSet
      .getPostCalibrations(makeTime(checkTime));

    TreeMap<String, Long> foundCalibrationIds = new TreeMap<String, Long>();
    for (Map.Entry<String, Calibration> entry : foundCalibrations.entrySet()) {
      foundCalibrationIds.put(entry.getKey(),
        null == entry.getValue() ? null : entry.getValue().getId());
    }

    assertTrue(mapsEqual(expectedCalibrations, foundCalibrationIds));
  }
}

/**
 * Testing implementation of the {@link Calibration} class.
 * 
 * <p>
 * The passed in {@code coefficients} are assumed to be valid and correct.
 * </p>
 */
class TestCalibration extends Calibration {

  private final boolean timeAffectsCalibration;

  private LinkedHashSet<String> coefficientNames;

  public TestCalibration(long id, Instrument instrument, String target,
    LocalDateTime deploymentDate, Map<String, String> coefficients,
    boolean timeAffectsCalibration)
    throws ParameterException, CalibrationException {

    super(id, instrument, "TEST", target);
    this.coefficientNames = new LinkedHashSet<String>(coefficients.keySet());
    setDeploymentDate(deploymentDate);
    setCoefficients(coefficients);
    this.timeAffectsCalibration = timeAffectsCalibration;
  }

  @Override
  public LinkedHashSet<String> getCoefficientNames(boolean includeHidden) {
    return coefficientNames;
  }

  @Override
  public boolean coefficientsValid() {
    return true;
  }

  @Override
  public Double calibrateValue(Double rawValue) {
    return rawValue;
  }

  @Override
  public String getCoefficientsLabel() {
    return "TEST";
  }

  @Override
  public Calibration makeCopy() {
    throw new NotImplementedException();
  }

  @Override
  protected boolean timeAffectsCalibration() {
    return timeAffectsCalibration;
  }
}
