package uk.ac.exeter.QuinCe.data.Instrument.Calibration;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.time.LocalDateTime;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.stream.Stream;

import org.apache.commons.lang3.NotImplementedException;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.CsvSource;
import org.junit.jupiter.params.provider.MethodSource;
import org.mockito.Mockito;

import uk.ac.exeter.QuinCe.TestBase.BaseTest;
import uk.ac.exeter.QuinCe.data.Instrument.Instrument;
import uk.ac.exeter.QuinCe.utils.ParameterException;

/**
 * Tests for the {@link CalibrationSet} class.
 */
public class CalibrationSetTest extends BaseTest {

  /**
   * A mock {@link Instrument} object.
   */
  protected static Instrument instrument = Mockito.mock(Instrument.class);

  /**
   * Generate a mock {@link CalibrationDB} instance.
   *
   * <p>
   * This instance will only respond to the methods
   * {@link CalibrationDB#timeAffectesCalibration()},
   * {@link CalibrationDB#allowCalibrationChangeInDataset()} and
   * {@link CalibrationDB#usePostCalibrations()} methods with the values
   * supplied.
   *
   * @param timeAffectsCalibration
   *          The value to be returned by calls to
   *          {@link CalibrationDB#timeAffectesCalibration()}.
   * @param allowCalibrationChangeInDataset
   *          The value to be returned by calls to
   *          {@link CalibrationDB#allowCalibrationChangeInDataset()}.
   * @param usePostCalibrations
   *          The value to be returned by calls to
   *          {@link CalibrationDB#usePostCalibrations()}.
   * @return The mocked {@link CalibrationDB}.
   */
  protected static CalibrationDB makeDbInstance(boolean timeAffectsCalibration,
    boolean allowCalibrationChangeInDataset, boolean usePostCalibrations) {

    CalibrationDB db = Mockito.mock(CalibrationDB.class);
    Mockito.when(db.timeAffectesCalibration())
      .thenReturn(timeAffectsCalibration);
    Mockito.when(db.allowCalibrationChangeInDataset())
      .thenReturn(allowCalibrationChangeInDataset);
    Mockito.when(db.usePostCalibrations()).thenReturn(usePostCalibrations);

    return db;
  }

  /**
   * Generate the target names used in these tests.
   *
   * @return The target names.
   */
  private Map<String, String> getTargets() {
    TreeMap<String, String> targets = new TreeMap<String, String>();
    targets.put("TARGET1", "TARGET1");
    targets.put("TARGET2", "TARGET2");
    return targets;
  }

  /**
   * Generate a set of coefficient values for a calibration.
   *
   * <p>
   * Generates a coefficient named {@code COEF1} with the values supplied.
   * </p>
   *
   * @param value
   *          The value for {@code COEF1}.
   * @return The coefficients.
   */
  protected static Map<String, String> makeCoefficient(String value) {
    TreeMap<String, String> coefficients = new TreeMap<String, String>();
    coefficients.put("COEF1", value);
    return coefficients;
  }

  /**
   * Generate a {@link LocalDateTime} for a specified day in January 2024, with
   * the time set to midnight.
   *
   * @param day
   *          The day of January.
   * @return The {@link LocalDateTime} object.
   */
  protected static LocalDateTime makeTime(int day) {
    return LocalDateTime.of(2024, 1, day, 0, 0, 0);
  }

  /**
   * Make a simple set of {@link Calibration}s.
   *
   * <p>
   * The calibrations generated are shown in the table below. The numbers for
   * each calibration are its database ID, used to verify the test results.
   * </p>
   * <table style="border: 1px solid black; width: 400px;">
   * <caption>Calibrations generated by this method, with day numbers in January
   * 2024.</caption>
   * <tr style="border-bottom: 1px solid black">
   * <th>Target</th>
   * <th>4th</th>
   * <th>5th</th>
   * <th>10th</th>
   * <th>12th</th>
   * <th>15th</th>
   * <th>17th</th>
   * </tr>
   * <tr>
   * <td>TARGET1</td>
   * <td>1</td>
   * <td>-</td>
   * <td>2</td>
   * <td>3</td>
   * <td>4</td>
   * <td>-</td>
   * </tr>
   * <tr>
   * <td>TARGET2</td>
   * <td>-</td>
   * <td>5</td>
   * <td>6</td>
   * <td>-</td>
   * <td>-</td>
   * <td>7</td>
   * </tr>
   * </table>
   *
   * @return The calibrations.
   * @throws Exception
   *           If the calibration creation fails.
   */
  private TreeMap<String, TreeSet<Calibration>> makeCalibrations()
    throws Exception {

    TreeMap<String, TreeSet<Calibration>> calibrations = new TreeMap<String, TreeSet<Calibration>>();

    TreeSet<Calibration> calibs1 = new TreeSet<Calibration>();
    calibs1.add(new TestCalibration(1L, instrument, "TARGET1", makeTime(4),
      makeCoefficient("10"), false));
    calibs1.add(new TestCalibration(2L, instrument, "TARGET1", makeTime(10),
      makeCoefficient("19"), false));
    calibs1.add(new TestCalibration(3L, instrument, "TARGET1", makeTime(12),
      makeCoefficient("20"), false));
    calibs1.add(new TestCalibration(4L, instrument, "TARGET1", makeTime(15),
      makeCoefficient("30"), false));

    calibrations.put("TARGET1", calibs1);

    TreeSet<Calibration> calibs2 = new TreeSet<Calibration>();
    calibs2.add(new TestCalibration(5L, instrument, "TARGET2", makeTime(5),
      makeCoefficient("15"), false));
    calibs2.add(new TestCalibration(6L, instrument, "TARGET2", makeTime(10),
      makeCoefficient("25"), false));
    calibs2.add(new TestCalibration(7L, instrument, "TARGET2", makeTime(17),
      makeCoefficient("35"), false));

    calibrations.put("TARGET2", calibs2);

    return calibrations;
  }

  /**
   * Test generation of a {@link CalibrationSet} with {@link Calibration}s
   * between the start and end times, and that exceptions are or are not thrown
   * according to the validity of the test parameters.
   *
   * @param start
   *          The start time of the {@link CalibrationSet}.
   * @param end
   *          The end time of the {@link CalibrationSet}.
   * @param expectException
   *          Whether or not an Exception should be thrown during the test.
   * @throws Exception
   *           If an <i>unexpected</i> error occurs.
   */
  @ParameterizedTest
  @CsvSource({ "5,6,false", "6,7,false", "9,12,true", "13,14,false",
    "11,15,true", "11,16,true", "18,20,false" })
  public void setupWithInterimTimesTest(int start, int end,
    boolean expectException) throws Exception {

    boolean exceptionThrown = false;

    try {
      new CalibrationSet(getTargets(), makeTime(start), makeTime(end),
        makeDbInstance(false, false, false), makeCalibrations());
    } catch (InvalidCalibrationDateException e) {
      exceptionThrown = true;
    } catch (Exception e) {
      throw e;
    }

    assertEquals(expectException, exceptionThrown);
  }

  /**
   * Tests for {@link CalibrationSet#hasCompletePrior()}.
   *
   * @param start
   *          The start time of the dataset.
   * @param shouldBeComplete
   *          Indicates whether or not pre-calibrations must be present for
   *          every target.
   * @throws Exception
   *           If any error occurs.
   * @see #makeCalibrations()
   */
  @ParameterizedTest
  @CsvSource({ "3,false", "4,false", "5,true", "9,true", "11,true", "13,true",
    "16,true", "18,true" })
  public void completePriorTest(int start, boolean shouldBeComplete)
    throws Exception {

    CalibrationSet calibrationSet = new CalibrationSet(getTargets(),
      makeTime(start), makeTime(20), makeDbInstance(false, true, false),
      makeCalibrations());

    assertEquals(shouldBeComplete, calibrationSet.hasCompletePrior());
  }

  /**
   * Tests for {@link CalibrationSet#hasCompletePost()}.
   *
   * @param end
   *          The end time of the dataset.
   * @param shouldBeComplete
   *          Indicates whether or not post-calibrations must be present for
   *          every target.
   * @throws Exception
   *           If any error occurs.
   * @see #makeCalibrations()
   */
  @ParameterizedTest
  @CsvSource({ "3,true", "4,true", "5,true", "9,true", "11,true", "13,true",
    "16,false" })
  public void completePostTest(int end, boolean shouldBeComplete)
    throws Exception {

    CalibrationSet calibrationSet = new CalibrationSet(getTargets(),
      makeTime(1), makeTime(end), makeDbInstance(false, true, true),
      makeCalibrations());

    assertEquals(shouldBeComplete, calibrationSet.hasCompletePost());
  }

  /**
   * Generate test parameters for
   * {@link #getCalibrationsTest(int, int, int, String[], Long[])}.
   *
   * @return The test parameters.
   */
  private static Stream<Arguments> getCalibrationsTestParams() {
    return Stream.of(
      Arguments.of(4, 7, 4, new String[] { "TARGET1", "TARGET2" },
        new Long[] { 1L, null }),
      Arguments.of(4, 7, 5, new String[] { "TARGET1", "TARGET2" },
        new Long[] { 1L, 5L }),
      Arguments.of(4, 7, 6, new String[] { "TARGET1", "TARGET2" },
        new Long[] { 1L, 5L }),
      Arguments.of(3, 18, 7, new String[] { "TARGET1", "TARGET2" },
        new Long[] { 1L, 5L }),
      Arguments.of(3, 18, 10, new String[] { "TARGET1", "TARGET2" },
        new Long[] { 2L, 6L }),
      Arguments.of(3, 18, 13, new String[] { "TARGET1", "TARGET2" },
        new Long[] { 3L, 6L }),
      Arguments.of(3, 18, 15, new String[] { "TARGET1", "TARGET2" },
        new Long[] { 4L, 6L }),
      Arguments.of(3, 18, 18, new String[] { "TARGET1", "TARGET2" },
        new Long[] { 4L, 7L }));
  }

  /**
   * Test to ensure that {@link CalibrationSet#getCalibrations(LocalDateTime)}
   * retrieves the correct {@link Calibration}s from a {@link CalibrationSet}.
   *
   * <p>
   * The test creates a {@link CalibrationSet} covering the time period
   * specified by {@code start} and {@code end}, and then checks that the
   * correct {@link Calibration}s are retrieved for the specified
   * {@code checkTime}.
   * </p>
   *
   * @param start
   *          The start time of the {@link CalibrationSet}.
   * @param end
   *          The end time of the {@link CalibrationSet}.
   * @param checkTime
   *          The time for which {@link Calibration}s are to be retrieved.
   * @param targets
   *          The targets for which {@link Calibration}s are to be retrieved.
   * @param calibrationIds
   *          The IDs of the {@link Calibration}s that should be retrieved.
   * @throws Exception
   *           If any error occurs.
   *
   * @see #makeCalibrations()
   * @see #getCalibrationsTestParams()
   */
  @ParameterizedTest
  @MethodSource("getCalibrationsTestParams")
  public void getCalibrationsTest(int start, int end, int checkTime,
    String[] targets, Long[] calibrationIds) throws Exception {

    CalibrationSet calibrationSet = new CalibrationSet(getTargets(),
      makeTime(start), makeTime(end), makeDbInstance(false, true, true),
      makeCalibrations());

    TreeMap<String, Long> expectedCalibrations = new TreeMap<String, Long>();
    for (int i = 0; i < targets.length; i++) {
      expectedCalibrations.put(targets[i], calibrationIds[i]);
    }

    TreeMap<String, Calibration> foundCalibrations = calibrationSet
      .getCalibrations(makeTime(checkTime));

    TreeMap<String, Long> foundCalibrationIds = new TreeMap<String, Long>();
    for (Map.Entry<String, Calibration> entry : foundCalibrations.entrySet()) {
      foundCalibrationIds.put(entry.getKey(),
        null == entry.getValue() ? null : entry.getValue().getId());
    }

    // If any targets weren't found, add them with a null Calibration ID.
    for (String target : getTargets().keySet()) {
      if (!foundCalibrationIds.containsKey(target)) {
        foundCalibrationIds.put(target, null);
      }
    }

    assertTrue(mapsEqual(expectedCalibrations, foundCalibrationIds));
  }

  /**
   * Generate test parameters for
   * {@link #getPostCalibrationsTest(int, int, int, String[], Long[])}.
   *
   * @return The test parameters.
   */
  private static Stream<Arguments> getPostCalibrationsTestParams() {
    return Stream.of(
      Arguments.of(4, 7, 4, new String[] { "TARGET1", "TARGET2" },
        new Long[] { 2L, 5L }),
      Arguments.of(4, 7, 5, new String[] { "TARGET1", "TARGET2" },
        new Long[] { 2L, 6L }),
      Arguments.of(4, 7, 6, new String[] { "TARGET1", "TARGET2" },
        new Long[] { 2L, 6L }),
      Arguments.of(3, 18, 7, new String[] { "TARGET1", "TARGET2" },
        new Long[] { 2L, 6L }),
      Arguments.of(3, 18, 10, new String[] { "TARGET1", "TARGET2" },
        new Long[] { 3L, 7L }),
      Arguments.of(3, 18, 13, new String[] { "TARGET1", "TARGET2" },
        new Long[] { 4L, 7L }),
      Arguments.of(3, 18, 15, new String[] { "TARGET1", "TARGET2" },
        new Long[] { null, 7L }),
      Arguments.of(3, 18, 18, new String[] { "TARGET1", "TARGET2" },
        new Long[] { null, null }));
  }

  /**
   * Test to ensure that {@link CalibrationSet#getCalibrations(LocalDateTime)}
   * retrieves the correct post-{@link Calibration}s from a
   * {@link CalibrationSet}.
   *
   * <p>
   * The test creates a {@link CalibrationSet} covering the time period
   * specified by {@code start} and {@code end}, and then checks that the
   * correct post-{@link Calibration}s are retrieved for the specified
   * {@code checkTime}.
   * </p>
   *
   * @param start
   *          The start time of the {@link CalibrationSet}.
   * @param end
   *          The end time of the {@link CalibrationSet}.
   * @param checkTime
   *          The time for which {@link Calibration}s are to be retrieved.
   * @param targets
   *          The targets for which {@link Calibration}s are to be retrieved.
   * @param calibrationIds
   *          The IDs of the {@link Calibration}s that should be retrieved.
   * @throws Exception
   *           If any error occurs.
   */
  @ParameterizedTest
  @MethodSource("getPostCalibrationsTestParams")
  public void getPostCalibrationsTest(int start, int end, int checkTime,
    String[] targets, Long[] calibrationIds) throws Exception {

    CalibrationSet calibrationSet = new CalibrationSet(getTargets(),
      makeTime(start), makeTime(end), makeDbInstance(false, true, true),
      makeCalibrations());

    TreeMap<String, Long> expectedCalibrations = new TreeMap<String, Long>();
    for (int i = 0; i < targets.length; i++) {
      expectedCalibrations.put(targets[i], calibrationIds[i]);
    }

    TreeMap<String, Calibration> foundCalibrations = calibrationSet
      .getPostCalibrations(makeTime(checkTime));

    TreeMap<String, Long> foundCalibrationIds = new TreeMap<String, Long>();
    for (Map.Entry<String, Calibration> entry : foundCalibrations.entrySet()) {
      foundCalibrationIds.put(entry.getKey(),
        null == entry.getValue() ? null : entry.getValue().getId());
    }

    assertTrue(mapsEqual(expectedCalibrations, foundCalibrationIds));
  }
}

/**
 * Testing implementation of the {@link Calibration} class.
 *
 * <p>
 * The passed in {@code coefficients} are assumed to be valid and correct.
 * </p>
 */
class TestCalibration extends Calibration {

  private final boolean timeAffectsCalibration;

  private LinkedHashSet<String> coefficientNames;

  public TestCalibration(long id, Instrument instrument, String target,
    LocalDateTime deploymentDate, Map<String, String> coefficients,
    boolean timeAffectsCalibration)
    throws ParameterException, CalibrationException {

    super(id, instrument, "TEST", target);
    this.coefficientNames = new LinkedHashSet<String>(coefficients.keySet());
    setDeploymentDate(deploymentDate);
    setCoefficients(coefficients);
    this.timeAffectsCalibration = timeAffectsCalibration;
  }

  @Override
  public LinkedHashSet<String> getCoefficientNames(boolean includeHidden) {
    return coefficientNames;
  }

  @Override
  public boolean coefficientsValid() {
    return true;
  }

  @Override
  public Double calibrateValue(Double rawValue) {
    return rawValue;
  }

  @Override
  public String getCoefficientsLabel() {
    return "TEST";
  }

  @Override
  public Calibration makeCopy() {
    throw new NotImplementedException();
  }

  @Override
  protected boolean timeAffectsCalibration() {
    return timeAffectsCalibration;
  }
}
